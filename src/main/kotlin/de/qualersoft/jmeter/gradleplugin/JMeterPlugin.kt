/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package de.qualersoft.jmeter.gradleplugin

import org.gradle.api.Project
import org.gradle.api.Plugin
import org.gradle.api.artifacts.Dependency
import org.gradle.api.artifacts.dsl.DependencyHandler
import org.gradle.api.internal.project.ProjectInternal
import org.gradle.api.plugins.JavaPlugin
import org.gradle.api.tasks.Delete
import org.gradle.internal.execution.BuildOutputCleanupRegistry
import org.gradle.language.base.internal.plugins.CleanRule
import org.gradle.language.base.plugins.LifecycleBasePlugin

private const val EXTENSION_NAME = "jmeter"

const val JMETER_EXEC = "jmeterExec"
const val JMETER_EXTENSION = "jmeterExtension"
const val JMETER_TOOL = "jmeterTool"

class JMeterPlugin : Plugin<Project> {

  override fun apply(project: Project) {
    val jmExt = project.extensions.create(
      EXTENSION_NAME,
      JMeterExtension::class.java,
      project
    )

    val javaPlg = JavaPlugin::class.java
    if (!project.plugins.hasPlugin(javaPlg)) {
      project.plugins.apply(javaPlg)
    }

    registerConfiguration(project, jmExt)
    project.afterEvaluate {
      registerTasks(it)
    }
  }

  private fun registerConfiguration(project: Project, jmExt: JMeterExtension) {
    val execConf = project.configurations.maybeCreate(JMETER_EXEC)
    execConf.isVisible = false
    // register the jmeter tool with it's desired version
    jmExt.tool.applyTo(execConf)

    val jmComp = project.configurations.maybeCreate(JMETER_EXTENSION)
    jmComp.description = "JMeter extensions like 3rd party plugins. See `jmCoreExt` for easy adding jmeter extensions."
    jmComp.isVisible = true
    jmComp.isCanBeConsumed = false
    jmComp.isCanBeResolved = true

    jmExt.tool.applyApacheComponents(jmComp)

    val tools = project.configurations.maybeCreate(JMETER_TOOL)
    tools.description = "Additional tool libraries that can be used within jmeter scripts. E.g. apache-commons"
  }

  private fun registerTasks(project: Project) {
    registerClean(project as ProjectInternal)
  }

  private fun registerClean(project: ProjectInternal) {
    if (null == project.tasks.findByName(LifecycleBasePlugin.CLEAN_TASK_NAME)) {
      // Register clean task (Taken from LifecycleBasePlugin.addClean)
      val buildDir = project.layout.buildDirectory
      val buildOutputCleanupRegistry = project.services.get(BuildOutputCleanupRegistry::class.java)
      buildOutputCleanupRegistry.registerOutputs(buildDir)

      val clean = project.tasks.register(LifecycleBasePlugin.CLEAN_TASK_NAME, Delete::class.java) {
        it.description = "Deletes the build directory"
        it.group = LifecycleBasePlugin.BUILD_GROUP
        it.delete(buildDir)
      }
      buildOutputCleanupRegistry.registerOutputs(clean.map {
        it.targetFiles
      })

      // Register clean rule (Taken from LifecycleBasePlugin.addCleanRule)
      project.tasks.addRule(CleanRule(project.tasks))
    }
  }
}

/**
 * Main 
 */
internal fun Project.jmeter(): JMeterExtension = extensions.getByName(EXTENSION_NAME) as? JMeterExtension
  ?: throw IllegalStateException("$EXTENSION_NAME is not of the correct type")

/**
 * Creates a jmeter core dependency based on the `jmeter.tool.group`.
 *
 * @param module The name of the apache component module. The `ApacheJMeter_` part will be prepended automatically.
 * @param version The version of the module, if omitted `jmeter.tool.version` will be used.
 */
// TODO did not work, atm `extensions` is not aware of our extension
//fun DependencyHandler.jmCoreExt(module: String, version: String? = null): Dependency {
//  val jmTool = extensions.getByType(JMeterExtension::class.java).tool
//  return create(jmTool.createComponentDependency(module, version)).apply { 
//    jmTool.applyBomWorkaround(this)
//  }
//}